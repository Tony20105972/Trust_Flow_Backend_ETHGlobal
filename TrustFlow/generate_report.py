import json
from datetime import datetime
from typing import Dict, Any, List, Optional

class ReportGenerator:
    """
    Generates a structured report (JSON) for contract deployment and execution results.
    This report can serve as source data for IPFS upload and NFT issuance.
    """
    def generate(self,
                 contract_name: str,
                 deploy_info: Dict[str, Any], # Includes contract_address, transaction_hash, abi
                 scan_results: Dict[str, Any], # Result from zk_oracle_detector
                 execution_logs: List[str], # Logs of contract function calls after deployment
                 summary_text: Optional[str] = None # Summary text from summarize_execution
                 ) -> Dict[str, Any]:
        """
        Generates a detailed JSON report on blockchain activity.

        Args:
            contract_name (str): The name of the deployed contract (e.g., "MyERC20Token").
            deploy_info (Dict[str, Any]): Dictionary of deployment results from DeploymentManager.
                                          Required keys: "contract_address", "transaction_hash", "abi".
            scan_results (Dict[str, Any]): Code scan results from ZKOracleDetector.
            execution_logs (List[str]): Key execution logs (function calls, events, etc.) after contract deployment.
            summary_text (Optional[str]): A brief summary text generated by ExecutionSummarizer.

        Returns:
            Dict[str, Any]: The generated report data (JSON serializable).
        """
        report = {
            "report_id": f"report_{datetime.utcnow().timestamp():.0f}", # Unique ID
            "timestamp_utc": datetime.utcnow().isoformat(),
            "contract_details": {
                "name": contract_name,
                "address": deploy_info.get("contract_address", "N/A"),
                "deployment_transaction_hash": deploy_info.get("transaction_hash", "N/A"),
                "abi": deploy_info.get("abi", []), # Include ABI to prove interactability
                # Future addition: transaction details like gasUsed, gasPrice
            },
            "security_and_feature_scan": scan_results, # Integrate ZKOracleDetector results
            "execution_summary": {
                "short_summary": summary_text or "No summary provided", # English translation
                "detailed_logs": execution_logs
            },
            # Future sections: Gas cost analysis, IPFS CID, NFT issuance info, etc.
        }
        print(f"‚úÖ Report '{report['report_id']}' generated successfully.") # English translation
        return report

    def save_as_json(self, report: Dict[str, Any], file_path: str = "contract_report.json") -> str:
        """
        Saves the generated report dictionary to a JSON file.

        Args:
            report (Dict[str, Any]): The report dictionary to save.
            file_path (str): The path and filename to save the JSON file.

        Returns:
            str: The full path to the saved file.
        """
        try:
            with open(file_path, "w", encoding="utf-8") as f:
                json.dump(report, f, indent=2, ensure_ascii=True) # ensure_ascii=True for standard English output
            print(f"‚úÖ Report saved to JSON file: {file_path}") # English translation
            return file_path
        except IOError as e:
            print(f"‚ùå Error saving report to JSON: {e}") # English translation
            raise

    # Placeholder for future PDF conversion functionality
    def generate_pdf(self, report: Dict[str, Any], file_path: str = "contract_report.pdf") -> str:
        """
        Converts and saves report data to a PDF file. (Implementation needed - using reportlab, WeasyPrint, etc.)
        For hackathon MVP, JSON is sufficient.
        """
        print(f"‚ÑπÔ∏è PDF report generation is not currently implemented. ({file_path})") # English translation
        # Example implementation:
        # from reportlab.lib.pagesizes import letter
        # from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
        # from reportlab.lib.styles import getSampleStyleSheet
        # doc = SimpleDocTemplate(file_path, pagesize=letter)
        # styles = getSampleStyleSheet()
        # flowables = []
        # flowables.append(Paragraph("Smart Contract Deployment Report", styles['h1']))
        # flowables.append(Spacer(1, 0.2 * inch))
        # ... Add report content as Paragraphs ...
        # doc.build(flowables)
        return file_path


# --- Integrated Test Code ---
if __name__ == "__main__":
    print("\n--- ReportGenerator Test Script Start ---") # English translation

    generator = ReportGenerator()

    # Mock deployment info
    mock_deploy_info = {
        "contract_address": "0xABC123DEF4567890ABC123DEF4567890ABC123DEF",
        "transaction_hash": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
        "abi": [{"type": "function", "name": "get", "inputs": [], "outputs": [{"type": "uint256", "name": ""}], "stateMutability": "view"}]
    }

    # Mock scan results (ensure reason is in English as per zk_oracle_detector.py)
    mock_scan_results = {
        "ZK_Features": {"detected": False, "reason": "Pattern not detected in the code.", "matched_patterns": []},
        "Oracle_Integration": {"detected": True, "reason": "Integration with external data oracles (e.g., Chainlink) detected.", "matched_patterns": ["chainlink", "AggregatorV3Interface"]},
        "KYC_AML_Compliance": {"detected": False, "reason": "Pattern not detected in the code.", "matched_patterns": []}
    }

    # Mock execution logs
    mock_execution_logs = [
        "Contract deployed successfully at 0xABC...",
        "Calling set(100) on contract...",
        "Function call 'get' returned: 100",
        "Event 'DataStored' emitted with value 100."
    ]

    # Mock summary text
    mock_summary = "SimpleStorage contract deployed, value set to 100." # English translation

    # Generate report
    report_data = generator.generate(
        contract_name="MockSimpleStorage",
        deploy_info=mock_deploy_info,
        scan_results=mock_scan_results,
        execution_logs=mock_execution_logs,
        summary_text=mock_summary
    )

    print("\n=== üî• [Generated Report Data] ===\n") # English translation
    print(json.dumps(report_data, indent=2, ensure_ascii=True)) # ensure_ascii=True

    # Save as JSON file
    output_json_path = "test_contract_report.json"
    saved_path = generator.save_as_json(report_data, output_json_path)
    print(f"\nSaved file verification: {saved_path}") # English translation

    # Read and verify saved file content
    try:
        with open(saved_path, "r", encoding="utf-8") as f:
            loaded_report = json.load(f)
            assert loaded_report["contract_details"]["address"] == mock_deploy_info["contract_address"]
            assert loaded_report["security_and_feature_scan"]["Oracle_Integration"]["detected"] == True
            print("‚úÖ JSON file save and load test successful.") # English translation
    except Exception as e:
        print(f"‚ùå JSON file verification failed: {e}") # English translation

    # Test PDF generation functionality (placeholder)
    generator.generate_pdf(report_data, "test_contract_report.pdf")

    print("\n--- ReportGenerator Test Script End ---") # English translation
